# Computer Science Summary Sheet
This is a Summary Sheet, a relatively much more condensed version of my Cheat Sheets. There is much less additional information, and it focuses solely on the content needed.

For a more comprehensive guide, you could check out the full Cheat Sheet and your own notes. Then, come back here and see how much you can remember!

Anyway, let's drop the waffle. Let's get started from the top of the spec down:

# Paper 2: Algorithms and programming

Computational thinking is having the ability to logically think about a problem and apply techniques to solve it. This allows algorithms to be designed with the end result of efficiently solving a problem.

<!-- A good comment informs its readers, corrects authors, and offers insights in a polite, respectful and constructive manner. All other comments fall into the category of rants, bile, insults or trolling. -->

In computing, a "problem" should be defined a 

## Thinking abstractly

### The nature and need for abstraction
Abstraction is a model of reality that has removed details which are irrelevant to the solution of the problem. A common example of this is the London Underground: only the different lines and stations need to be shown to get from one place to another, irrespective of the geography/exact distance/type of train, etc., **so information is hidden without losing meaning**.

Abstraction models are thus a representation of reality so that a solution can be found whilst only taking into account what is required and nothing else - facilitating computational and algorithmic approaches 

Abstraction is needed so that a problem can be solved in a simple way, thereby speeding up the time it takes to create and execute a solution without overloading the user with information. For example, the user can just be told to copy and paste a file from one document to another, without needing to know the details of how the program that runs the document software works, how the OS is allocating memory to the program, and how the file of the document itself is being read to and written into secondary storage with the physical fipping of bits or electrons being trapped.

A model for, for example, a shop and its revenue, may take into account the number of visitors, how much is spent and if there are any refunds. This does not take into account the process of welcoming people into a shop, how long people spend inside, the items people are going to buy, as this is largely unnecesary for the specifc task: to calculate revenue.


### Thinking ahead
There is a need to think ahead to calculate the steps involved in creating a solution. The inputs, processes and outputs should be worked out before the algorithm to calculate the outputs based on the inputs is written! 

Inputs to a problem are information relevant, devised from the abstract model, to the problem











<!--stackedit_data:
eyJoaXN0b3J5IjpbLTM3MzU0OTU3MSwxNDIyNTcwNzI5XX0=
-->